import express from 'express' // import express as we would for other third party libraries/ frameworks. You will need to add "type": "module", to the package.json for this to work.
import { CategoryModel } from './db.js'
import entryRoutes from './routes/entry_routes.js'
import dotenv from 'dotenv' // you will need to install this first with (npm i dotenv)
import cors from 'cors'

dotenv.config() // call the config method. This will read the .env file, parse it and add the variables to the environment so that we can access them but they remain private and encapsulated. 

// Now we will initialize the express app. 
const app = express() // creates a new instance of an express object and gives us an object to represent it. 

// Because I know we will be receiving post, put and patch requests which will pass through a JSON body. I now call the .use method to use the JSON middleware. It can be used to parse a json body. If the incoming request is a JSON request (it will know that from the Conent-Type header) it will parse that JSON so that we have an actual JavaScript object we can access. It will put this as a key in the request object.    
// I want a middleware that will look at the request to see if there is a body and if so see if that body is JSON. If that's the case it will parse it and create a params object with the JSON is has passed and add it to the request object so that later middleware can get at it with the key params. To insert middleware into our production line that isn't a route (done before routes are processed) we use add.use() and provide it with the middleware in question which we can custom design by providing a function.

app.use(cors()) // here origin is a wildcard* that will allow anyone access to the database.This will add the appropraite access control allow origin header. The default behaviour is to allow any origin which is useful for development purposes. In production you would pass in the URL (domain) for the front end to only allow requests from that domain.  Then API requests can only be made from the front end which helps to secure it.  
app.use(express.json()) // only parses JSON. If something passed in isn't JSON it will ignore it and change nothing.  It does this before it even checks the routes. By the time any routes are processed req.body is accessable. Parses a JSON body that comes in with the request. 

//The instance of express has been created but it isn't running. It won't work and doesn't serve anything untill be run the server. We need to launch the server once it has been configered. The server will listen on the specified port and listed for any requests. It then runs through the routes until it finds a match. If one matches it will run the code attached to the route.  You must run a server and have it listen on the port for incoming connections. 
// Now we define routes. This is a route for the homepage. We use app.get() because we want to respond to a HTTP get request. 
app.get('/', (req, res) => res.send({ info: "Journal API 2023" })) //req = request res= response.  The single / is not required on the end of each route. 
// middleware exsists for all different HTTP verbs. This allows me to handle get requests. It works in a similar way to react router. Our first prop in react.router is the path and the second is the component we want to render. Here the first is the path and the second is a callback function. The calllback function receives two parameters from express request and response. These are both objects. Request is used to get infomation about the request, including any data that may have been passed thorugh and the response object is used to manipulate or send back the response to the client.  The callback function is executed if the path matches. It's placement is critical. Each station must be in a specific sequence for it to work. The request and response object needs to be processed in the correct sequence. This is inserting middleware into the pipeline. If the url doesn't match it will ignore it and if we have another piece of middleware the execution would pass to the next piece of middleware. The next middleware would execute. Then it would potentially do something with the request. Here we use the respond object with the send method to send back anything we want. If we give it a JS object or array it will automatically convert it to JSON for us and apply the correct content type header and when the client sees it, it knows that it is JSON data. We can send strings, objects. By default it will set the status code to 200 but this can be changed for example using res.status(404).send('Sorry, I can't find that'). Here we have sent back an object with one key value pair. The send method will automatically convert that to JSON.    You can't chain together send requests. To send back multiple things these would need to be wrapped in an object. 
app.get('/categories', async (req, res) => res.send(await CategoryModel.find()))
 // I can chain in a call to status before the send to change the status code. This would change the status code to 204. 
 
app.use('/entries', entryRoutes) // use this routers object and the routes within it. We first pass it the base URL first so that it will prefix entries to the start of all the routes. This means that if the URI of the current request doesn't begin with /entries then the entry routes middleware wont even run it will just get skipped which is more efficient. It also gives me flexibility is I want to move the routes I can just change it in the one place.    

export default app